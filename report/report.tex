% Class and style of the document.
\documentclass[12pt]{article}

% Package and configuration.

% Language and encoding packages.
\usepackage[french]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

% Mathematics package.
\usepackage{amsmath}
\usepackage{amstext}

% Figures package.
\usepackage{graphicx}
\usepackage{wrapfig}

% Charts package.
\usepackage{pgfplots}
\pgfplotsset{compat=1.16}
\usepgfplotslibrary{units}
% Define style for charts.
\pgfplotsset{custom plot/.style={
        width            = 13cm,
        height           = 9cm,
        axis lines       = left,
        grid             = major,
        grid style       = {dashed},
        legend pos       = north west,
        ylabel           = Temps d'exécution,
        y unit           = \si{\second},
        enlarge y limits = upper,
        xlabel           = Taille des données,
        x unit           = N \text{ blocs}*K \text{ réels double précision},
        xticklabel style = {
            /pgf/number format/precision = 3,
        },
        log ticks with fixed point,
    }
}
\pgfplotsset{custom lines/.style={
        smooth,
        tension = 0.1,
    }
}
\pgfplotsset{custom line/.style={
        custom lines,
        color   = red,
        mark options = {
            fill = black,
        }
    }
}

% Symbols package.
\usepackage{siunitx}

% Formatter package.
%% Page break between section.
\usepackage{titlesec}
\newcommand{\sectionbreak}{\clearpage}
%% Use clickable URLs.
\usepackage{url}

% Hypertext links.
\usepackage[hidelinks]{hyperref}

% Footer.
\usepackage{lastpage}
\usepackage{fancyhdr}
\pagestyle{fancy}
% Clear headers and footers.
\fancyhead{}
% \renewcommand{\headrulewidth}{0pt}
% \renewcommand{\footrulewidth}{0pt}
% Define footers.
\fancyfoot[RE,LO]{Pierre AYOUB}
\fancyfoot[RE,CO]{\text{\thepage} sur \pageref{LastPage}}
\fancyfoot[RE,RO]{Océane FLAMANT}

% Paragraph.
\setlength{\parskip}{1ex}

% Quote.
\usepackage[style=french,french=guillemets]{csquotes}

\begin{document}

\title{Tri parallèle d'un tableau avec OpenMP}
\author{Pierre AYOUB -- Océane FLAMANT}

\maketitle

\begin{figure}[b]
    \centering
    \includegraphics[scale=0.3]{pictures/isty.jpg}
\end{figure}

\tableofcontents

\section{Introduction}

Durant la réalisation de ce projet, nous avions comme objectifs, dans un premier
temps, d'implémenter en langage C un algorithme de tri parallèle destiné à trier
une grande base de données. Dans un second temps, il nous fallait effectuer des
mesures du temps d'exécution de notre programme en fonction de plusieurs
paramètres, tels que le nombre de threads utilisés ou encore la taille des données.

Plusieurs contraintes nous étaient imposées :
\begin{itemize}  
    \item{Le squelette de l'algorithme à suivre était donné dans l'énoncé ;}
    \item{Nous avions à utiliser la bibliothèque de programmation parallèle OpenMP pour paralléliser notre algorithme;}
    \item{Nous avions trois fonctions principales à implémenter de la manière suivante :}
        \begin{description}
            \item[generator() :] {remplit un tableau de taille $K$ avec des nombres réels aléatoires;}
            \item[tri() :] {tri un tableau de taille $K$ ;}
            \item[tri-merge() :] {à partir de deux tableaux chacun de taille $K$ et trié, renvoie deux tableaux triés vérifiant que toutes les valeurs du premier tableau sont inférieures à celles du deuxième.}
        \end{description}
\end{itemize}

\section{Développement du programme}

Dans cette partie, nous allons expliquer et justifier les choix que nous avons
fait afin d'implémenter l'algorithme demandé, ainsi que les modifications qui
ont dû être effectuées.

\subsection{Structure du programme}

Nos fonctions \emph{generator()} et \emph{tri()} suivent scrupuleusement
l'algorithme défini dans l'énoncé. Cependant, nous avions le libre arbitre
concernant l'implémentation de la fonction \emph{tri()}.
    
Pour l'algorithme de tri, nous avons choisi le \emph{tri à bulles} (connu aussi
sous le nom de \emph{tri par permutation} ou encore \emph{tri par propagation}).
Nous reviendrons sur ces performances plus tard, mais nous pouvons souligner le
fait que c'est un tri simple à implémenter et qu'il fait partie de la famille
des tris en place : il n'a pas besoin de recopier un tableau annexe pour que le
tri s'effectue. 

\subsection{Adaptation de l'algorithme}

Nous avons rencontré quelques déconvenues avec l'algorithme donné. En effet, une
fois nos fonctions réalisées et vérifiées, nous avons lancé le programme et le
résultat obtenu n'était pas le bon. Les valeurs contenues dans les tableaux
étaient triés mais les tableaux n'étais pas dans l'odre attendu. Nous avons donc
dû effectuer une légère adaptation : en effet, en C, les indices commencent à $0$
et non à $1$, comme donné dans l'algorithme.

Tout d'abord, chaque \emph{boucle for} commence à $0$ et s'arrête à $N$. Ensuite
nous avons supprimé les $+1$ des variables $k$, $b1$ et $b2$ car les boucles
commencent à 0. Enfin, pour $b2$, le $K$ est devenu $k$ (ce dernier étant une
correction d'une erreur de l'énoncé). 

En résumé :
\begin{itemize}
    \item $k = 1+(j\bmod 2) \Rightarrow k = (j\bmod 2)$
    \item $b_1 = 1+(k+2*i)\bmod N \Rightarrow b_1 = (k+2*i)\bmod N$
    \item $b_2 = 1+(K+2*i+1)\bmod N \Rightarrow b_2 = (k+2*i+1)\bmod N$
\end{itemize}

\section{Performances}

Nous allons maintenant discuter des performances de notre programme. D'un
point de vue algorithmique, dû à notre choix de \emph{tri à bulle}, les
performances ne devraient pas être excellentes. En effet, le \emph{tri à bulle}
a une complexité en moyenne en $\mathcal{O}(n^2)$, ce qui est bien moins bon
qu'un algorithme tel que le \emph{tri rapide} ayant une complexité en moyenne en
$\mathcal{O}(n.\log n)$. Cependant, étant donné que nous sommes dans une projet
de programmation parallèle et non d'algorithmique, il y a deux raisons qui
jusitifie le choix du \emph{tri à bulle} :
\begin{itemize}
    \item Une \enquote{mauvaise} complexité algorithmique nous permettra de mieux
        mettre en évidence l'importance du parallélisme ;
    \item L'algorithme parcours de multiples fois le tableau sur toute longueur,
        ainsi cela va rendre possible la mise en avant des défauts de cache.
\end{itemize}

\subsection{Mesures}

Avant de commenter nos mesures, il nous semble bon d'expliquer un minimum ce qui
va suivre. Notre programme voit son comportement modifié par 4 paramètres :
\begin{description}
    \item[Taille de la base de données :]{correspond au nombre de tableaux
        multiplié par la taille d'un tableau $(N*K)$. Il faut multiplier ce
        nombre par la taille d'un réel double précision pour l'exprimer en
        octet ;}
    \item[N :]{nombre de tableaux ;}
    \item[K :]{taille d'un tableau ;}
    \item[OMP\_NUM\_THREADS :]{nombre de threads exécutant le programme.}
\end{description}

Il est important de se rendre compte que si $N < \text{OMP\_NUM\_THREADS}$,
alors les $\text{OMP\_NUM\_THREADS} - N$ threads ne pourront pas obtenir de
travail.

De tout les paramètres des trois graphiques suivant, rien n'as été choisi au
hasard. Par défaut :
\begin{itemize}
        \item OMP\_NUM\_THREADS est égal aux nombre de coeurs de la machine hôte ;
        \item $N$ est calculé à partir d'une formule déterminée empiriquement,
            permettant d'approcher la valeur optimale de $N$ pour un $N*K$ donné
            après une série de mesures sur une de nos machine ;
        \item $K$ prend sa valeur en fonction de $N$.
\end{itemize}

Enfin, vous noterez que les échelles de nos graphiques sont des échelles
logarithmiques, avec un facteur 10 entre chaque graduation. 

\begin{figure}
    \begin{center}
        \begin{tikzpicture}
            \begin{loglogaxis} [
                    custom plot,
                    title = $N \text{ = } \exp(\log_{10}(N*K))$ ; $K \text{ = } \frac{(N*K)}{N}$ ; $\text{OMP\_NUM\_THREADS = } \mathopen|\text{CPU cores}\mathclose|$,
                ]
                \addplot+[custom line] table [
                    x       = data size,
                    y       = exec time,
                    col sep = comma,
                ] {charts/chart1.csv};
            \end{loglogaxis}
        \end{tikzpicture}
        \caption{Temps d'exécution en fonction de la taille des données}
        \label{time-to-data-size}
    \end{center}
\end{figure}

\begin{figure}
    \begin{center}
        \begin{tikzpicture}
            \begin{loglogaxis} [
                    custom plot,
                    title = $\text{OMP\_NUM\_THREADS = } \mathopen|\text{CPU cores}\mathclose|$ ; $K \text{ = } \frac{(N*K)}{N}$,
                ]
                \foreach \i in {2,16,64,256,1024}
                    \addplot+[custom lines] table [
                        x       = data size,
                        y       = exec time n eq \i,
                        col sep = comma,
                    ] {charts/chart2.csv};
                \addlegendentry{$N = 2$};
                \addlegendentry{$N = 16$};
                \addlegendentry{$N = 64$};
                \addlegendentry{$N = 256$};
                \addlegendentry{$N = 1024$};
            \end{loglogaxis}
        \end{tikzpicture}
        \caption{Temps d'exécution en fonction de la taille des données et du nombre de blocs}
        \label{time-to-data-size-and-blocks}
    \end{center}
\end{figure}

\begin{figure}
    \begin{center}
        \begin{tikzpicture}
            \begin{loglogaxis} [
                    custom plot,
                    legend pos = north west,
                    title = $N \text{ = } \exp(\log_{10}(N*K))$ ; $K \text{ = } \frac{(N*K)}{N}$,
                ]
                \foreach \i in {1,4,16,64}
                    \addplot+[custom lines] table [
                        x       = data size,
                        y       = exec time omp_num_threads eq \i,
                        col sep = comma,
                    ] {charts/chart3.csv};
                \addlegendentry{$\text{OMP\_NUM\_THREADS} = 1$};
                \addlegendentry{$\text{OMP\_NUM\_THREADS} = 4$};
                \addlegendentry{$\text{OMP\_NUM\_THREADS} = 16$};
                \addlegendentry{$\text{OMP\_NUM\_THREADS} = 64$};
            \end{loglogaxis}
        \end{tikzpicture}
        \caption{Temps d'exécution en fonction de la taille des données et du nombre de threads}
        \label{time-to-data-size-and-threads}
    \end{center}
\end{figure}

\subsection{Perspectives d'amélioration}
    
Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor
incididunt ut labore et dolore magna aliqua.

\section{Conclusion}

Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor
incididunt ut labore et dolore magna aliqua.

\end{document}
